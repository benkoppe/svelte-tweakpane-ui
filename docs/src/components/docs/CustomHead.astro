---
// Inject fontsource font preloads
// We have to do this here instead of in astro.config starlight.head
// so we can get the bundled asset URL for the font files

import type { Props } from '@astrojs/starlight/props';
import Default from '@astrojs/starlight/components/Head.astro';
import ThemeWatcher from './ThemeWatcher.astro';
import FontPreload from './FontPreload.astro';
---

<FontPreload />
<ThemeWatcher />

<script is:inline>
	(async () => {
		// Watch for an element's first debut in the DOM
		async function observeDomUntilFound(query, scope = document, giveUpAfterLoad = true) {
			return new Promise((resolve) => {
				const element = scope.querySelector(query);
				if (element) {
					resolve(element);
				} else {
					const observer = new MutationObserver((mutationsList, observer) => {
						for (const mutation of mutationsList) {
							if (mutation.type === 'childList') {
								const foundElement = scope.querySelector(query);
								if (foundElement) {
									observer.disconnect();
									if (giveUpAfterLoad) {
										window.removeEventListener('load', onLoad);
									}
									resolve(foundElement);
									break;
								}
							}
						}
					});

					function onLoad() {
						// Window loaded without finding element, could be perfectly normal
						observer.disconnect();
						resolve(undefined);
					}

					observer.observe(scope, { childList: true, subtree: true });
					if (giveUpAfterLoad) {
						window.addEventListener('load', onLoad, { once: true, passive: true });
					}
				}
			});
		}

		// Sidebar State Persistence
		const key = 'sl-sidebar-state';
		let savedState;

		const savedStateJson = sessionStorage.getItem(key);
		if (savedStateJson) {
			try {
				savedState = JSON.parse(savedStateJson);
			} catch (e) {
				console.error('Error parsing saved position:', e);
			}
		}

		// Watch for the sidebar's debut in the DOM
		const sidebarContent = await observeDomUntilFound(
			'div#starlight__sidebar > div.sidebar-content'
		);

		if (sidebarContent) {
			// open ancestor details of the active item
			const activeLinkDetailElements = [
				...sidebarContent.querySelectorAll('details:has(a[aria-current="page"])')
			];

			activeLinkDetailElements.forEach((detail) => {
				detail.setAttribute('open', '');
			});

			// Restore state from previous navigation
			// (but keep the active item's ancestors open regardless)
			const detailElements = [...sidebarContent.querySelectorAll('details')];

			if (savedState) {
				savedState.details.forEach((isOpen, i) => {
					if (isOpen) {
						detailElements[i].setAttribute('open', '');
					} else if (!activeLinkDetailElements.includes(detailElements[i])) {
						detailElements[i].removeAttribute('open');
					}
				});

				sidebarContent.scrollTop = savedState.scrollTop;
			}

			// Scroll the active list item into view if necessary
			const activeLi = sidebarContent.querySelector('a[aria-current="page"]').parentElement;
			if (activeLi) {
				const sidebarRect = sidebarContent.getBoundingClientRect();
				const liRect = activeLi.getBoundingClientRect();
				if (liRect.top < sidebarRect.top || liRect.bottom > sidebarRect.bottom) {
					activeLi.scrollIntoView({ behavior: 'instant', block: 'nearest' });
				}
			}

			// Save user state before navigating
			window.addEventListener('beforeunload', () => {
				sessionStorage.setItem(
					key,
					JSON.stringify({
						details: detailElements.map((detail) => detail.hasAttribute('open')),
						scrollTop: sidebarContent.scrollTop
					})
				);
			});
		}

		// Table of Contents Selection
		const toc = await observeDomUntilFound('nav[aria-labelledby="starlight__on-this-page"]');
		if (toc) {
			const tocLinks = [...toc.querySelectorAll('a')];
			const headingQueries = tocLinks.map((link) => link.getAttribute('href') || '');
			const headings = await Promise.all(
				headingQueries.map(async (id) => {
					return await observeDomUntilFound(id);
				})
			);

			// cache styles
			const headingsMarginTop = headings.map((heading) => {
				const style = window.getComputedStyle(heading);
				return parseInt(style.marginTop, 10);
			});

			const navBarHeight =
				(await observeDomUntilFound('header'))?.getBoundingClientRect().height || 0;
			// `<summary>` only exists in mobile ToC, so will fall back to 0 in large viewport component.
			// todo... guarantee existence?
			const mobileTocHeight = toc.querySelector('summary')?.getBoundingClientRect().height || 0;
			const activationThreshold = navBarHeight + mobileTocHeight;

			let willScroll = false;

			// find the id of the first heading that's in view
			function findActiveHeadingId() {
				for (let i = 0; i < headings.length; i++) {
					const top = headings[i].getBoundingClientRect().top - headingsMarginTop[i];

					if (top >= activationThreshold) {
						return i === 0 ? headings[i].id : headings[i - 1].id;
					}
				}
				return headings[headings.length - 1].id;
			}

			function activateTocLink(idOrHash) {
				const id = idOrHash && idOrHash.startsWith('#') ? idOrHash.slice(1) : idOrHash;
				tocLinks.forEach((link) => {
					if (link.getAttribute('href')?.slice(1) === id) {
						!link.hasAttribute('aria-current') && link.setAttribute('aria-current', 'true');
					} else {
						link.hasAttribute('aria-current') && link.removeAttribute('aria-current');
					}
				});
			}

			// special case, navigated to an anchor link
			if (window.location.hash.length > 0) {
				activateTocLink(window.location.hash);
			} else {
				activateTocLink(findActiveHeadingId());
			}

			// watch for hash changes
			window.addEventListener('hashchange', () => {
				willScroll = true;
				activateTocLink(window.location.hash);
			});

			// watch for scroll
			window.addEventListener(
				'scroll',
				() => {
					// ignore hash-change-initiated scrolls
					if (willScroll) {
						willScroll = false;
					} else {
						activateTocLink(findActiveHeadingId());
					}
				},
				{ passive: true }
			);
		}
	})();
</script>

<Default {...Astro.props} />
