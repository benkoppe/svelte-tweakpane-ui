---
import { getCollection, type CollectionEntry } from 'astro:content';

interface Props {
	scope: 'lib' | 'docs' | 'all';
}

function titleCase(str: string) {
	return str
		.split(' ')
		.map((word) => {
			return word.charAt(0).toUpperCase() + word.slice(1);
		})
		.join(' ');
}

function getNameFromEmail(name: string) {
	if (name.includes('@')) {
		return name.split('@')[0].replace(/[_-]/g, ' ');
	}
	return name;
}

type LicenseEntry = CollectionEntry<'acknowledgments'>['data'][string][number];

const { scope } = Astro.props;

const data = (
	await getCollection(
		'acknowledgments',
		(f) => scope === 'all' || f.id === `acknowledgments-${scope}`
	)
)
	// each collection entry
	.reduce((acc, collection) => {
		return [
			...acc,
			...Object.values(collection.data).reduce((acc, packages) => {
				return [...acc, ...packages];
			}, [] as LicenseEntry[])
		];
	}, [] as LicenseEntry[]);

// Get unique list of publisher names
const names = data
	.reduce((acc: string[], { author }) => {
		if (author) {
			// Split compound comma-delimited publishers as needed
			author.split(/\s*(?:\sand\s|,|&)\s*/).forEach((subItem) => {
				const subPublisher = titleCase(getNameFromEmail(subItem.trim()));
				if (subPublisher && !acc.includes(subPublisher)) {
					acc.push(subPublisher);
				}
			});
		}
		return acc;
	}, [])
	// Exclude me and some other vague things
	.filter((name) => !['Eric Mika', 'contributors', 'inc.'].includes(name.toLowerCase()))
	// Filter out case-insensitive duplicates, but keep the version with the most capitalization
	.filter((name, i, arr) => {
		const lower = name.toLowerCase();
		const index = arr.findIndex((n) => n.toLowerCase() === lower);
		return index === i;
	})
	// remove duplicate names like Microsoft, Microsoft Corp., Microsoft Corporation, keep the one without the Corp or Corporation suffix
	.filter((name, i, arr) => {
		const lower = name.toLowerCase();
		const index = arr.findIndex(
			(n) => n.toLowerCase().replace(/(corp\.|corporation)$/, '') === lower
		);
		return index === i;
	})

	// Don't break names
	.map((n) => n.replace(/ /, '\u00a0'))
	// Sort by last name
	.sort((a, b) => {
		return a.localeCompare(b);
	});
---

{names.length}

{names.length && names.join(', ')}
