---
import { getCollection, type CollectionEntry } from 'astro:content';

interface Props {
	scope: 'lib' | 'docs' | 'all';
}

function titleCase(str: string) {
	return str
		.split(' ')
		.map((word) => {
			return word.charAt(0).toUpperCase() + word.slice(1);
		})
		.join(' ');
}

function getNameFromEmail(name: string) {
	if (name.includes('@')) {
		return name.split('@')[0].replace(/[_-]/g, ' ');
	}
	return name;
}

type LicenseEntry = CollectionEntry<'acknowledgments'>['data'][string][number];

const { scope } = Astro.props;

const data = (
	await getCollection(
		'acknowledgments',
		(f) => scope === 'all' || f.id === `acknowledgments-${scope}`
	)
)
	// each collection entry
	.reduce((acc, collection) => {
		return [
			...acc,
			...Object.values(collection.data).reduce((acc, packages) => {
				return [...acc, ...packages];
			}, [] as LicenseEntry[])
		];
	}, [] as LicenseEntry[]);

// Get unique list of publisher names
const names = data
	.reduce((acc: string[], { author }) => {
		if (author) {
			// Split compound comma-delimited publishers as needed
			author.split(',').forEach((subItem) => {
				const subPublisher = titleCase(getNameFromEmail(subItem.trim()));
				if (subPublisher && !acc.includes(subPublisher)) {
					acc.push(subPublisher);
				}
			});
		}
		return acc;
	}, [])
	// Exclude me
	.filter((name) => name !== 'Eric Mika')
	// Don't break names
	.map((n) => n.replace(/ /, '\u00a0'))
	// Sort by last name
	.sort((a, b) => {
		return a.split(' ').at(-1)!.toLowerCase().localeCompare(b.split(' ').at(-1)!.toLowerCase());
	});
---

{names.length && names.join(', ')}
