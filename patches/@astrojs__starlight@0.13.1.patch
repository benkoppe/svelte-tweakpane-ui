diff --git a/components/MarkdownContent.astro b/components/MarkdownContent.astro
index 0d40cd47ed269a706b05242f0c7994ed2a95a43d..4ac5cd2744816c0c7f7cd327eb823328a0311b19 100644
--- a/components/MarkdownContent.astro
+++ b/components/MarkdownContent.astro
@@ -4,3 +4,96 @@ import '../style/markdown.css';
 ---
 
 <div class="sl-markdown-content"><slot /></div>
+
+{
+	/* This is intentionally inlined to avoid FOUC. It lives here and not in
+	TableOfContents.astro because because it needs access to the complete document
+	outline. Setting a global function in TableOfContents.astro and invoking it
+	here results in FOUC on Safari. */
+}
+<script is:inline>
+	(() => {
+		// Table of Contents Selection
+		const toc = document.querySelector('starlight-toc nav');
+		const mobileToc = document.querySelector('mobile-starlight-toc nav');
+
+		if (toc && mobileToc) {
+			const tocLinks = [...toc.querySelectorAll('a')];
+			const mobileTocLinks = [...mobileToc.querySelectorAll('a')];
+			const headings = tocLinks.map((link) => {
+				const id = link.getAttribute('href')?.slice(1);
+				return document.getElementById(id || '');
+			});
+
+			// cache styles
+			const headingsMarginTop = headings.map((heading) => {
+				const style = window.getComputedStyle(heading);
+				return parseInt(style.marginTop, 10);
+			});
+
+			const navBarHeight = document.querySelector('header')?.getBoundingClientRect().height || 0;
+			// `<summary>` only exists in mobile ToC, so will fall back to 0 in large viewport component.
+			// todo... guarantee existence?
+			const mobileTocHeight = mobileToc.querySelector('summary')?.getBoundingClientRect().height || 0;
+			const activationThreshold = navBarHeight + mobileTocHeight;
+
+			let willScroll = false;
+
+			// find the id of the first heading that's in view
+			function findActiveHeadingId() {
+				for (let i = 0; i < headings.length; i++) {
+					const top = headings[i].getBoundingClientRect().top - headingsMarginTop[i];
+
+					if (top >= activationThreshold) {
+						return i === 0 ? headings[i].id : headings[i - 1].id;
+					}
+				}
+				return headings[headings.length - 1].id;
+			}
+
+			function activateTocLink(idOrHash) {
+				const id = idOrHash && idOrHash.startsWith('#') ? idOrHash.slice(1) : idOrHash;
+				let activeLink;
+				[...mobileTocLinks, ...tocLinks].forEach((link) => {
+					if (link.getAttribute('href')?.slice(1) === id) {
+						!link.hasAttribute('aria-current') && link.setAttribute('aria-current', 'true');
+						activeLink = link;
+					} else {
+						link.hasAttribute('aria-current') && link.removeAttribute('aria-current');
+					}
+				});
+
+				// update mobile ToC display
+				const display = mobileToc.querySelector('.display-current');
+				if (display) display.textContent = activeLink.textContent;
+			}
+
+			// special case, navigated to an anchor link
+			if (window.location.hash.length > 0) {
+				activateTocLink(window.location.hash);
+			} else {
+				activateTocLink(findActiveHeadingId());
+			}
+
+			// watch for hash changes
+			window.addEventListener('hashchange', () => {
+				willScroll = true;
+				activateTocLink(window.location.hash);
+			});
+
+			// watch for scroll
+			window.addEventListener(
+				'scroll',
+				() => {
+					// ignore hash-change-initiated scrolls
+					if (willScroll) {
+						willScroll = false;
+					} else {
+						activateTocLink(findActiveHeadingId());
+					}
+				},
+				{ passive: true }
+			);
+		}
+	})();
+</script>
diff --git a/components/MobileTableOfContents.astro b/components/MobileTableOfContents.astro
index 03a4972f2bcacd2c7553a6d63830ba25d4d92830..5a93161c31614f3b895e70efb66baba676753775 100644
--- a/components/MobileTableOfContents.astro
+++ b/components/MobileTableOfContents.astro
@@ -1,7 +1,7 @@
 ---
 import { useTranslations } from '../utils/translations';
 import Icon from '../user-components/Icon.astro';
-import TableOfContentsList from './TableOfContents/TableOfContentsList.astro';
+import TableOfContentsList from './TableOfContentsList.astro';
 import type { Props } from '../props';
 
 const { locale, toc } = Astro.props;
@@ -110,15 +110,7 @@ const t = useTranslations(locale);
 </style>
 
 <script>
-	import { StarlightTOC } from './TableOfContents/starlight-toc';
-
-	class MobileStarlightTOC extends StarlightTOC {
-		override set current(link: HTMLAnchorElement) {
-			super.current = link;
-			const display = this.querySelector('.display-current') as HTMLSpanElement;
-			if (display) display.textContent = link.textContent;
-		}
-
+	class MobileStarlightTOC extends HTMLElement {
 		constructor() {
 			super();
 			const details = this.querySelector('details');
diff --git a/components/Search.astro b/components/Search.astro
index 4162f4001f981f8e60c7853651b4d4617f4fc681..94e88563c7a7cb806562e60ebbd728e2ecdb00ed 100644
--- a/components/Search.astro
+++ b/components/Search.astro
@@ -47,6 +47,9 @@ const pagefindTranslations = {
 </site-search>
 
 <script>
+	import { stripTrailingSlash, ensureTrailingSlash } from '../utils/path';
+	import project from 'virtual:starlight/project-context';
+
 	class SiteSearch extends HTMLElement {
 		constructor() {
 			super();
@@ -54,6 +57,24 @@ const pagefindTranslations = {
 			const closeBtn = this.querySelector<HTMLButtonElement>('button[data-close-modal]')!;
 			const dialog = this.querySelector('dialog')!;
 			const dialogFrame = this.querySelector('.dialog-frame')!;
+			const processResult =
+				project.trailingSlash === 'always'
+					? ((result) => {
+							result.url = ensureTrailingSlash(result.url);
+							result.sub_results?.forEach((subResult) => {
+								subResult.url = ensureTrailingSlash(subResult.url);
+							});
+							return result;
+						})
+					: project.trailingSlash === 'never'
+						? ((result) => {
+								result.url = stripTrailingSlash(result.url);
+								result.sub_results?.forEach((subResult) => {
+									subResult.url = stripTrailingSlash(subResult.url);
+								});
+								return result;
+							})
+						: undefined;
 
 			/** Close the modal if a user clicks on a link or outside of the modal. */
 			const onClick = (event: MouseEvent) => {
@@ -118,6 +139,7 @@ const pagefindTranslations = {
 						showImages: false,
 						translations,
 						showSubResults: true,
+						processResult
 					});
 				});
 			});
diff --git a/components/Sidebar.astro b/components/Sidebar.astro
index 38dc898d3697b5b15f8e812711258757927d8088..293d0aa75fb4bf35f7f3559266fea4bad9f31e52 100644
--- a/components/Sidebar.astro
+++ b/components/Sidebar.astro
@@ -11,3 +11,84 @@ const { sidebar } = Astro.props;
 <div class="md:sl-hidden">
 	<MobileMenuFooter {...Astro.props} />
 </div>
+
+{/* This is intentionally inlined to avoid FOUSC. */}
+<script is:inline>
+	(() => {
+		const sidebarContent = document.getElementById('starlight__sidebar')?.firstElementChild;
+
+		if (sidebarContent) {
+			// could have been as simple as
+			// sidebarContent.querySelectorAll('details:has(a[aria-current="page"])')
+			function findAllDetailsAncestors(activeLink, boundaryElement) {
+				const detailsElements = new Set();
+				let parent = activeLink.parentElement;
+				while (parent && parent !== boundaryElement) {
+					if (parent.tagName === 'DETAILS') {
+						detailsElements.add(parent);
+					}
+					parent = parent.parentElement;
+				}
+				return [...detailsElements];
+			}
+
+			// open ancestor details of the active item
+			const activeLink = sidebarContent.querySelector('a[aria-current="page"]');
+			const activeLinkDetailAncestors = findAllDetailsAncestors(activeLink, sidebarContent);
+
+			activeLinkDetailAncestors.forEach((detail) => {
+				detail.setAttribute('open', '');
+			});
+
+			const detailElements = [...sidebarContent.querySelectorAll('details')];
+
+			// Restore state from previous navigation
+			// (but keep the active item's ancestors open regardless)
+			const key = 'sl-sidebar-state';
+			const savedStateJson = sessionStorage.getItem(key);
+
+			if (savedStateJson) {
+				let savedState;
+
+				try {
+					savedState = JSON.parse(savedStateJson);
+				} catch (e) {
+					console.error('Error parsing saved position:', e);
+				}
+
+				if (savedState) {
+					savedState.details.forEach((isOpen, i) => {
+						if (isOpen) {
+							detailElements[i].setAttribute('open', '');
+						} else if (!activeLinkDetailAncestors.includes(detailElements[i])) {
+							detailElements[i].removeAttribute('open');
+						}
+					});
+
+					sidebarContent.scrollTop = savedState.scrollTop;
+				}
+			}
+
+			// Scroll the active list item into view if necessary
+			const activeLi = sidebarContent.querySelector('a[aria-current="page"]').parentElement;
+			if (activeLi) {
+				const sidebarRect = sidebarContent.getBoundingClientRect();
+				const liRect = activeLi.getBoundingClientRect();
+				if (liRect.top < sidebarRect.top || liRect.bottom > sidebarRect.bottom) {
+					activeLi.scrollIntoView({ behavior: 'instant', block: 'nearest' });
+				}
+			}
+
+			// Save user state before navigating
+			window.addEventListener('beforeunload', () => {
+				sessionStorage.setItem(
+					key,
+					JSON.stringify({
+						details: detailElements.map((detail) => detail.hasAttribute('open')),
+						scrollTop: sidebarContent.scrollTop
+					})
+				);
+			});
+		}
+	})();
+</script>
\ No newline at end of file
diff --git a/components/TableOfContents/starlight-toc.ts b/components/TableOfContents/starlight-toc.ts
deleted file mode 100644
index a5de15bd336c198fbc6b788b6351e2a3ae278dd4..0000000000000000000000000000000000000000
diff --git a/components/TableOfContents.astro b/components/TableOfContents.astro
index 4b0f1d118b401c66c0f50c6da685cc62fb7fb7bf..ad393429565c337a61c3bdc741d47b787646b26c 100644
--- a/components/TableOfContents.astro
+++ b/components/TableOfContents.astro
@@ -1,6 +1,6 @@
 ---
 import { useTranslations } from '../utils/translations';
-import TableOfContentsList from './TableOfContents/TableOfContentsList.astro';
+import TableOfContentsList from './TableOfContentsList.astro';
 import type { Props } from '../props';
 
 const { locale, toc } = Astro.props;
@@ -9,7 +9,7 @@ const t = useTranslations(locale);
 
 {
 	toc && (
-		<starlight-toc data-min-h={toc.minHeadingLevel} data-max-h={toc.maxHeadingLevel}>
+		<starlight-toc>
 			<nav aria-labelledby="starlight__on-this-page">
 				<h2 id="starlight__on-this-page">{t('tableOfContents.onThisPage')}</h2>
 				<TableOfContentsList toc={toc.items} />
@@ -18,4 +18,15 @@ const t = useTranslations(locale);
 	)
 }
 
-<script src="./TableOfContents/starlight-toc"></script>
+{/* See script in MarkdownContent.astro to set active item. */}
+
+{/* This must remain to avoid FOUC */}
+<script>
+	class StarlightTOC extends HTMLElement {
+		constructor() {
+			super();
+		}
+	}
+
+	customElements.define('starlight-toc', StarlightTOC);
+</script>
\ No newline at end of file
diff --git a/components/TableOfContents/TableOfContentsList.astro b/components/TableOfContentsList.astro
similarity index 97%
rename from components/TableOfContents/TableOfContentsList.astro
rename to components/TableOfContentsList.astro
index db370b6126e9e3a7eb3562b9258ecbfcc29caa41..4090cdbfa46238f476bc87768ab59b9bb2fcd6c7 100644
--- a/components/TableOfContents/TableOfContentsList.astro
+++ b/components/TableOfContentsList.astro
@@ -1,5 +1,5 @@
 ---
-import type { TocItem } from '../../utils/generateToC';
+import type { TocItem } from '../utils/generateToC';
 
 interface Props {
 	toc: TocItem[];
diff --git a/utils/path.ts b/utils/path.ts
index 68b1f5c2b7ac83f3a0927635e2a39065d3d7818c..73b6615870dee805932df98882640ff5288fc935 100644
--- a/utils/path.ts
+++ b/utils/path.ts
@@ -1,12 +1,26 @@
+/** Find end of URL path, before hash and query parameters if necessary */
+function getPathBoundary(href: string): number {
+	const hashIndex = href.indexOf("#");
+	const queryIndex = href.indexOf("?");
+	return hashIndex !== -1
+		? hashIndex
+		: queryIndex !== -1
+		? queryIndex
+		: href.length;
+}
+
 /** Ensure the passed path starts with a leading slash. */
 export function ensureLeadingSlash(href: string): string {
-	if (href[0] !== '/') href = '/' + href;
+	if (href[0] !== "/") href = "/" + href;
 	return href;
 }
 
 /** Ensure the passed path ends with a trailing slash. */
 export function ensureTrailingSlash(href: string): string {
-	if (href[href.length - 1] !== '/') href += '/';
+	const pathBoundary = getPathBoundary(href);
+	if (href[pathBoundary - 1] !== "/") {
+		href = href.slice(0, pathBoundary) + "/" + href.slice(pathBoundary);
+	}
 	return href;
 }
 
@@ -18,14 +32,17 @@ export function ensureLeadingAndTrailingSlashes(href: string): string {
 }
 
 /** Ensure the passed path does not start with a leading slash. */
-export function stripLeadingSlash(href: string) {
-	if (href[0] === '/') href = href.slice(1);
+export function stripLeadingSlash(href: string): string {
+	if (href[0] === "/") href = href.slice(1);
 	return href;
 }
 
 /** Ensure the passed path does not end with a trailing slash. */
-export function stripTrailingSlash(href: string) {
-	if (href[href.length - 1] === '/') href = href.slice(0, -1);
+export function stripTrailingSlash(href: string): string {
+	const pathBoundary = getPathBoundary(href);
+	if (href[pathBoundary - 1] === "/") {
+		href = href.slice(0, pathBoundary - 1) + href.slice(pathBoundary);
+	}
 	return href;
 }
 
@@ -37,16 +54,26 @@ export function stripLeadingAndTrailingSlashes(href: string): string {
 }
 
 /** Remove the extension from a path. */
-export function stripHtmlExtension(path: string) {
+export function stripHtmlExtension(path: string): string {
 	const pathWithoutTrailingSlash = stripTrailingSlash(path);
-	return pathWithoutTrailingSlash.endsWith('.html') ? pathWithoutTrailingSlash.slice(0, -5) : path;
+	const pathBoundary = getPathBoundary(path);
+	const htmlIndex = pathWithoutTrailingSlash.indexOf(".html");
+	return htmlIndex !== -1 && htmlIndex === pathBoundary - 5
+		? pathWithoutTrailingSlash.slice(0, pathBoundary - 5) +
+				pathWithoutTrailingSlash.slice(pathBoundary)
+		: path;
 }
 
 /** Add '.html' extension to a path. */
-export function ensureHtmlExtension(path: string) {
+export function ensureHtmlExtension(path: string): string {
 	path = stripLeadingAndTrailingSlashes(path);
-	if (!path.endsWith('.html')) {
-		path = path ? path + '.html' : '/index.html';
+	const pathBoundary = getPathBoundary(path);
+	const htmlIndex = path.indexOf(".html");
+	if (htmlIndex === -1 || htmlIndex !== pathBoundary - 5) {
+		path =
+			pathBoundary === 0
+				? "index.html" + path.slice(pathBoundary)
+				: path.slice(0, pathBoundary) + ".html" + path.slice(pathBoundary);
 	}
 	return ensureLeadingSlash(path);
 }
